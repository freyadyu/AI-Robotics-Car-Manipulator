#pragma config(Sensor, in2,    Potmeter_shoulder, sensorPotentiometer)
#pragma config(Sensor, in3,    Potmeter_elbow, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  LimitSwitch,    sensorTouch)
#pragma config(Sensor, dgtl3,  RotEncoder,     sensorRotation)
#pragma config(Sensor, dgtl4,  QuadEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Sonar,          sensorSONAR_mm)
#pragma config(Motor,  port1,           Motor_Shoulder, tmotorVex393, openLoop)
#pragma config(Motor,  port2,           Servo_Hand,    tmotorServoStandard, openLoop)
#pragma config(Motor,  port3,           Motor_Elbow,   tmotorServoContinuousRotation, openLoop)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*******************************************************************************
 *
 * This file is the final version of 2-joint planar robotic manipulator coding.
 * Author: Dian Yu; Zhexu Fan, Chao Duan
 * Create Date: March 31 2015
 * Last Edited Date: April 30 2015
 *
 *******************************************************************************/


/*******************************************************************************
 *`
 *  MOTORS & SENSORS:
 *
 *    [I/O Port]          [Name]              [Type]        [Description]                     *|
 *  Motor  - Port 1      Motor_Shoulder VEX 2-wire module      motor
 *  Motor  - Port 2      Servo_Hand     VEX 3-wire module      servo
 *  Motor  - Port 3      Motor_Elbow    VEX 3-wire module      motor
 *  Analog - Port 2      Potmeter_shoulder
 *  Analog - Port 3      Potmeter_elbow
 *  Digital- Port 2      LimitSwitch
 *  Digital- Port 3      RotEncoder    VEX Shaft Encoder     Left side
 *  Digital- Port 4,5    QuadEncoder   VEX Shaft Encoder     Right side
 *  Digital- Port 11,12  Sonar         VEX Sonar Sensor      Front mounted, facing forward
 *******************************************************************************/

/******** Functions Prototypes********/
void ShoulderMove(int motorSpeed);       //Function renders Shoulder to move
void ElbowMove(int motorSpeed);          //Function renders Elbow to move
void ShoulderMoveTo(int targetShoulder); //Function helps Shoulder move to Target Angle
void ElbowMoveTo(int targetElbow);       //Function helps Elbow move to Target Angle
void ServoHand(int servoPosition);       //Function manipulates hand open and clip

/******** Declare Global Variables****/
bool doShoulder = false;
bool doElbow = false;
bool doHand = false;


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
  // variables to be used:
  int sonar_value;                // Will hold the current reading of the sonar sensor.
  int potmeter_shoulder_value;    // Potentiometer value of shoulder
  int potmeter_elbow_value;       // Potentiometer value of elbow
  int switch_value;
  int encoder_value;
  

  double distance = 0.0;           // Initialize distance between cans and shoulder point 
  double arm_length = 295.00;      // The arm length between shoulder and elbow is 295mm
  double front_arm_length = 410.0; // The arm length between elbow to the center of the hand is 410mm, named front_arm_length

  int shoulderTarget;              // Shoulder Target Angel
  int elbowTarget;                 // Elbow Target Angel

  SensorValue[QuadEncoder] = 0;    //clear and reset the encoder
  SensorValue[RotEncoder] = 0;


  /**********************While Loop Start**************************************/
  while(true)
    {
      potmeter_shoulder_value = SensorValue(Potmeter_shoulder);
      //writeDebugStreamLine("shoulder potmeter value = %d\n", potmeter_shoulder);

      potmeter_elbow_value = SensorValue(Potmeter_elbow);
      //writeDebugStreamLine("elbox potmeter value = %d\n", Potmeter_elbow);

      switch_value = SensorValue(LimitSwitch);
      //writeDebugStreamLine("whisker value = %d\n", switch_value);

      sonar_value = SensorValue(Sonar);
      //  writeDebugStreamLine("sonar value = %d\n", sonar_value);

      encoder_value = SensorValue(QuadEncoder);
      //writeDebugStreamLine("Quad encoder value = %d\n", encoder_value);

      encoder_value = SensorValue(RotEncoder);
      //writeDebugStreamLine("Rotation encoder value = %d\n", encoder_value);


      /*********Initalize to the inital position to set up 2-joint planar manipulator***********/
      ServoHand(-40);      // Hand Servo control--> 100: open (-40): clip
      wait1Msec(1000);     // Wait for 1 second
      ServoHand(120);      // Open hand as the starting signal

      ShoulderMoveTo(165); // First move shoulder to 165 degree away from the shoulder constructionn chasis
      ElbowMoveTo(70);     // Then mover elbow to 70 degree away from shoulder



      /**********End of initialization*****************/
      wait10Msec(200);     // Wait for 0.2 seconds


      /***************Sensor Reader*****************/
      if (sonar_value > 741 || sonar_value < 393){       // The reach range of 2-joint planar manipulator is between 741 and 393
	while (sonar_value > 741 || sonar_value < 343){  // If out of range, rescan.
	  sonar_value = SensorValue(Sonar);
	}
      }
      else{                          // Otherwise set doShoulder and doElbow to be true and start to reach cans.
	doShoulder = true;
	doElbow = true;
	doHand = false;
      }

      distance = 110 + sonar_value;  // Set distance to be the sonar value and the distance between sona sensor and shoulder shelf chasis

      //*************Shoulder Part*******************************/
      
      // Get the theoretical shoulder angle based on Triangle Algorithm
      double pi_Angle =  acos((pow(arm_length, 2) + pow(distance, 2) - pow(front_arm_length, 2))/2/distance/arm_length) *180 / PI;
      // Actual shoulder angle from shoudler chasis is theoretical angel puls 95 degree for angel error tolerance
      shoulderTarget = (int) pi_Angle + 95;

      /******************Elbow Part******************************/
      
      // Get the theoretical elbow angle based on Triangle Algorithm
      double el_Angle =  acos((pow(front_arm_length, 2) - pow(distance, 2) + pow(arm_length, 2))/2/front_arm_length/arm_length) *180 / PI;
      // Casting theoretical elbow angle to acutal elbow angle
      elbowTarget = (int) el_Angle;


      // Move Elbow to the Target Angle first
      if (doElbow){
	ElbowMoveTo(elbowTarget);
	doElbow = false;    // Disable Elbow motion
      }//end of do elbow movement
      
      // Then move shoulder to the Target Angle
      if(doShoulder){
	ShoulderMoveTo(shoulderTarget);
	doShoulder = false; // Disable Shoulder motion
	doHand = true;      // Enable Hand motion
      }//end of do shoulder movement

      // Move hand to clip cans
      if(doHand){
	ServoHand(100);    // Note 100: open (-40):clip
	wait1Msec(1000);
	ServoHand(-60);    // Clip cans


      }//end of do hand

      /*******After catch the cans, move Shoulder and Elbow backwards to drop the catched can*****/
      ShoulderMoveTo(150); // Move Shoulder to 150 degree away from shoudler shelf chasis
      ElbowMoveTo(222);    // Move Elbow to 222 degreee away to the bottom side of the shoulder
      ServoHand(120);      // Open hand to drop can
      ElbowMoveTo(160);    // After dropping the can, move elbow back to 160 away from the bottom side of the shoulder

    }// end of while loop

}// end of main


/*****************Helper Functions************************/

// Enable shoulder to move, control motor
void ShoulderMove(int motorSpeed){
  motor[Motor_Shoulder] = motorSpeed;
  wait1Msec(20);
}

// Enable elbow to move, control motor
void ElbowMove(int motorSpeed){
  motor[Motor_Elbow] = motorSpeed;
  wait1Msec(20);
}

// Enable hand to move, contrl servo
void ServoHand(int servoPosition){
  motor[Servo_Hand] = servoPosition;
  wait1Msec(20);
}

// Control Shoulder move to the Target Angle
void ShoulderMoveTo(int targetShoulder) {
  int targetPot = 0;                               // Initialize targetPot for Target Angle
  targetPot = 2493 - 12 * targetShoulder;          // Set Target Angle according to the formula we calculated from data collection
  int currentPot = SensorValue(Potmeter_shoulder); // Save current potentiometer as current Pot
  
  // Adjust shoulder position in the while loop
  while (currentPot > targetPot + 5 || currentPot < targetPot -5) { // While current position is greater or less than the target position more than (+-5)
    if (currentPot > targetPot + 5){  // If current position is lower than the target position more than 5
      ShoulderMove(70);               // Move shoulder up
      wait1Msec(30);
      ShoulderMove(0);
    }
    else if (currentPot < targetPot -5){ // If current position is higher than the target position more than 5
      ShoulderMove(-50);                 // Move shoulder down
      wait1Msec(30);
      ShoulderMove(0);
    }
    else {
      ShoulderMove(0);                  // If after adjusting, shoulder's current position is in the range, then don't move
    }
    currentPot = SensorValue(Potmeter_shoulder);  // Set current potentiometer reading value as new currentPot
  }
  ShoulderMove(0);                     // If shoulder's curent position is within the error tolerance, then don't move
}

// Control Elbow move to the Target Angle
void ElbowMoveTo(int targetElbow) {
  int targetPot = 0;                    // Initialize tartPot for Target Angle
  // Set Target Angle according to the formula we calculated from data collection
  targetPot = 5178 - 18 * targetElbow;  // Note: The max potentiometer reader is 4055, min is 1242 (212 degree)
  // Set currentPot equal to current potmeter
  int currentPot = SensorValue(Potmeter_elbow);

  // Adjust elbow position in the while loop
  while (currentPot > targetPot + 5 || currentPot < targetPot - 5) { // While current position is greater or less than the target position more than (+-5)
    if (currentPot > targetPot + 5){   // If current position is closer to the bottom side of shoulder than the target angle more than 5
      ElbowMove(45);                   // Move away from bottom side of shoulder
      wait1Msec(30);
      ElbowMove(0);
    }
    else if (currentPot < targetPot - 5){ // If current position is away from the bottom side of shoulder than the target angle more than 5
      ElbowMove(-35);                     // Move closer to the bottom side of shoulder
      wait1Msec(30);
      ElbowMove(0);
    }
    else {
      ElbowMove(0);                      // If after adjusting, elbow's current position is in the range, then don't move
    }
    currentPot = SensorValue(Potmeter_elbow);  // Set current potentiometer reading value as new currentPot
  }
  ElbowMove(0);                          // If elbow's current position is within the error tolerance, then don't move.
}

/***********************End of Helper Functions and whole Task******************************************/
