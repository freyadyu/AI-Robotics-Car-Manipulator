#pragma config(Sensor, in1,    Light_sensor,   sensorReflection)
#pragma config(Sensor, in2,    Potmeter_sensor, sensorPotentiometer)
#pragma config(Sensor, in3,    Front_light_sensor, sensorReflection)
#pragma config(Sensor, dgtl1,  BumpLeft,       sensorTouch)
#pragma config(Sensor, dgtl2,  BumpRight,      sensorTouch)
#pragma config(Sensor, dgtl3,  RotEncoder,     sensorRotation)
#pragma config(Sensor, dgtl4,  QuadEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  BumpFront,      sensorTouch)
#pragma config(Sensor, dgtl7,  BumpInner,      sensorTouch)
#pragma config(Sensor, dgtl8,  Sonar,          sensorSONAR_mm)
#pragma config(Sensor, dgtl12, Jumper,         sensorTouch)
#pragma config(Motor,  port1,           Left_Motor,    tmotorVex393, openLoop)
#pragma config(Motor,  port2,           Servo,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          Right_Motor,   tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*******************************************************************************
 *
 * This file is for maze car project
 *
 *******************************************************************************/



/*******************************************************************************
 *
 * Author: Dian Yu, Zhexu Fan; Chao Duan
 * Last Modified Date: July. 6th 2016
 *
 *******************************************************************************/


/*******Functions Prototypes***********/
void ServoMove(int servoPosition);
void MotorMove_Left(int motorSpeed);
void MotorMove_Right(int motorSpeed);
// Robot truns left approximately 90 degree
void TurnLeft();
// Robot turns right approximately 90 degree
void TurnRight();
// Moving direction adjustment while moving forward along the walls
void GoAhead(int sonar_value);


// Initialization of motor speed
int speed_left = 65;
int speed_right = 66;
// Assumed distance betwwen walls and robot
int target_dis = 150;
//int  J  = true;

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{

  //go straight 1s no matter what, when starts
  MotorMove_Left(65);  //test turn left Mseconds: 1277
  MotorMove_Right(66); //test turn right Mseconds: 1500
  wait1Msec(800);


  // variables to be used:
  int  sonar_value;      // Will hold the current reading of the sonar sensor.
  int   sonar_value_past;
  int  light_value;       // Not used __for_future_develop__
  int  front_light_value; // Not used __for_future_develop__
  int  potmeter_value;    // Not used __for_future_develop__
  int   bumper_left_value; // Left front corner bumper
  int   bumper_right_value;// Right front corner bumper
  int   bumper_front_value;// Front button bumper

  // new bumper added on 3/6/2016
  int   bumper_Inner; // Inner bumper
  int  timer_value;
  // left flag to decide turn right or not
  int   left_flag = 0;

  SensorValue[QuadEncoder] = 0;         //clear and reset the encoder
  SensorValue[RotEncoder] = 0;



  /***************testing code**********************/
  /*MotorMove_Left(30); //left 1277
    MotorMove_Right(0); //right 1500
    wait1Msec(10800);

    MotorMove_Left(0); //left 1277
    MotorMove_Right(30); //right 1500
    wait1Msec(10000);*/

  //MotorMove_Left(speed_left); //left 1277
  //MotorMove_Right(speed_right); //right 1500
  //wait1Msec(100000);


  //-----------------------------------------------------------------



  //ingore when need to turn left right after entrance;
  /*
    int entrance_sonar_value;
    int entrance_light_value;
    entrance_light_value = SensorValue(Front_light_sensor);

    entrance_sonar_value = SensorValue(Sonar);
  */

  while(true)
    {
      // When left flag is equal to 3, try to turn right to get out of dilemma
      if (left_flag == 3) {

	TurnRight();
	left_flag = 0;
      }
      else {

	ClearTimer(T1);

	// Initialization of sensor values
	light_value = SensorValue(Light_sensor);
	writeDebugStreamLine("light value = %d\n", light_value);

	potmeter_value = SensorValue(Potmeter_sensor);
	writeDebugStreamLine("potmeter value = %d\n", potmeter_value);

	bumper_left_value = SensorValue(BumpLeft);
	writeDebugStreamLine("left bumper value = %d\n", bumper_left_value);

	bumper_right_value = SensorValue(BumpRight);
	writeDebugStreamLine("right bumper value = %d\n", bumper_right_value);

	bumper_front_value = SensorValue(BumpFront);
	writeDebugStreamLine("front bumper value = %d\n", bumper_front_value);

	bumper_Inner = SensorValue(BumpInner);
	writeDebugStreamLine("left bumper value = %d\n", bumper_Inner);

	//switch_value = SensorValue(LimitSwitch);
	//writeDebugStreamLine("whisker value = %d\n", switch_value);

	sonar_value = SensorValue(Sonar);
	// Reread sonar value if it's equal to -1
	while (sonar_value == -1) {
	  sonar_value = SensorValue(Sonar);
	}
	writeDebugStreamLine("whisker value = %d\n", sonar_value);

	wait1Msec(100);

	//Gets the value of Timer T1 in 1ms increments and stores it in a variable
	timer_value = time1[T1];

	//printVal = (int)timerVal;
	writeDebugStreamLine("time to read these values = %d\n", timer_value);


	timer_value = time1[T3];

	writeDebugStream("time since start = %d\n", timer_value);
	writeDebugStreamLine("...................................");//(35) =limit of chars to put in debug stream....?

	// When left and right front corner bumpers both hit, means robot stucks at the "L" size corner.
	if (bumper_left_value && bumper_right_value) {
	  // Moving back
	  MotorMove_Left(-30);
	  MotorMove_Right(-33);
	  wait1Msec(500);
	  // Turn right fr 600 Msecs
	  MotorMove_Left(45);
	  MotorMove_Right(-45);
	  wait1Msec(600);

	  MotorMove_Left(0);
	  MotorMove_Right(0);
	}

	// If right front bumper is not hitten, just left front corner bumper
	else if(bumper_left_value){

	  // And font bumper is hitten
	  if (bumper_front_value) {
	    // Moving back
	    MotorMove_Left(-30);
	    MotorMove_Right(-33);
	    wait1Msec(500);
	    // Turn right for a big angle
	    MotorMove_Left(45);
	    MotorMove_Right(-45);
	    wait1Msec(600);
	  }

	  // Front bumper is not hitten
	  else {
	    // Moving back
	    MotorMove_Left(-30);
	    MotorMove_Right(-33);
	    wait1Msec(500);
	    // Turn right for a smaller angle, like slightly direction tilt fix
	    MotorMove_Left(30);
	    MotorMove_Right(-30);
	    wait1Msec(400);
	  }

	  //After changing direction, moving forward
	  MotorMove_Left(45);
	  MotorMove_Right(46);
	  wait1Msec(500);

	  MotorMove_Left(0);
	  MotorMove_Right(0);
	}

	// If only the right front bumper is hitten, nothing related to left front bumper
	else if(bumper_right_value){
	  // Moving back
	  MotorMove_Left(-30);
	  MotorMove_Right(-33);
	  wait1Msec(500);
	  // Turn Left slightly to tilt
	  MotorMove_Left(-30);
	  MotorMove_Right(30);
	  wait1Msec(400);
	  // Moving forward
	  MotorMove_Left(45);
	  MotorMove_Right(46);
	  wait1Msec(500);

	  MotorMove_Left(0);
	  MotorMove_Right(0);
	}

	// When only inner bumper is hitten
	else if(bumper_Inner){
	  // Moving back
	  MotorMove_Left(-30);
	  MotorMove_Right(-33);
	  wait1Msec(500);
	  // Turn left for a bigger angle
	  MotorMove_Left(-30);
	  MotorMove_Right(30);
	  wait1Msec(700);
	  // Moving forward
	  MotorMove_Left(45);
	  MotorMove_Right(46);
	  wait1Msec(500);

	  MotorMove_Left(0);
	  MotorMove_Right(0);
	}

	//---Turning direction-------------------------
	//Front: Yes Left: No ==> turn left and move
	else if (sonar_value - sonar_value_past > 400 || sonar_value > 450){
	  if(bumper_front_value || bumper_Inner || bumper_left_value || bumper_right_value) {
	    MotorMove_Left(-30);
	    MotorMove_Right(-33);
	    wait1Msec(500);
	  }
	    
	  TurnLeft();
	  left_flag++;
	}

	//Front: No Left: Yes  ==> keep moving
	else if (!bumper_front_value) {
	  GoAhead(sonar_value);
	  left_flag = 0;
	  //J = true;
	}


	//Front: Yes  Left: Yes  ==> turn right 90 degree
	//else if (front_light_value > entrance_light_value + 80 && sonar_value < entrance_sonar_value + 50 && sonar_value > entrance_sonar_value - 50){
	else {
	  TurnRight();
	  left_flag = 0;
	  //J = true;
	}

      }//left flag
      sonar_value_past = sonar_value;
    }//while true
}//task

void TurnLeft() {
  //MotorMove_Left(30);
  //MotorMove_Right(33);
  //wait1Msec(100);
  MotorMove_Left(0);
  MotorMove_Right(0);
  wait1Msec(100);
  // Turn left for 90 degree
  MotorMove_Left(-55);
  MotorMove_Right(55);
  wait1Msec(650);

  MotorMove_Left(0);
  MotorMove_Right(0);
  // Moving forward
  MotorMove_Left(65);
  MotorMove_Right(66);
  wait1Msec(950);
  /*sonar_value = SensorValue(Sonar);
    while(sonar_value == -1){
    wait10Msec(1);
    }*/
}

void TurnRight () {
  // Moving back
  MotorMove_Left(-30);
  MotorMove_Right(-33);
  wait1Msec(500);

  MotorMove_Left(0);
  MotorMove_Right(0);
  wait1Msec(100);
  // Turn Right for 90 degree
  MotorMove_Left(55);
  MotorMove_Right(-55);
  wait1Msec(650);

  MotorMove_Left(0);
  MotorMove_Right(0);

  MotorMove_Left(65);
  MotorMove_Right(66);
  wait1Msec(950);
  /*sonar_value = SensorValue(Sonar);
    while(sonar_value == -1){
    wait10Msec(1);
    }*/
}

void GoAhead(int sonar_value) {
  int offset = 40;
  int sonar_value_new;
  sonar_value_new = SensorValue(Sonar);
  // Robot pos far from left wall
  if (sonar_value > (target_dis + 30)) {
    
    // Heading forward within small difference
    if (sonar_value - sonar_value_new < 5 && sonar_value - sonar_value_new > -5 ) {
      MotorMove_Left(speed_left - offset);
      MotorMove_Right(speed_right);
      wait1Msec(60);
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right);
      wait1Msec(35);
      //MotorMove_Left(speed_left);
      //MotorMove_Right(speed_right - offset);
      //wait1Msec(75);
      //MotorMove_Left(speed_left);
      //MotorMove_Right(speed_right);
      //wait1Msec(40);
    }
    // When robot is leaving left walls
    else if (sonar_value - sonar_value_new <= -5){
      // Tilt back to left walls
      MotorMove_Left(speed_left - offset);
      MotorMove_Right(speed_right);
      wait1Msec(75);
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right);
      wait1Msec(40);
      //MotorMove_Left(speed_left);
      //MotorMove_Right(speed_right - offset);
      //wait1Msec(40);
      //MotorMove_Left(speed_left);
      //MotorMove_Right(speed_right);
      //wait1Msec(40);
    }

  }
  // When robot is too close to the left walls
  else if (sonar_value < (target_dis)) {

    // Heading forward within small difference
    if (sonar_value - sonar_value_new < 5 && sonar_value - sonar_value_new > -5 ) {
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right - offset);
      wait1Msec(60);
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right);
      wait1Msec(35);
      //MotorMove_Left(speed_left - offset);
      //MotorMove_Right(speed_right);
      //wait1Msec(75)
      //MotorMove_Left(speed_left);
      //MotorMove_Right(speed_right);
      //wait1Msec(40);
    }

    // When robot is getting super closer to the left walls
    else if (sonar_value - sonar_value_new >= 5){
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right - offset);
      wait1Msec(75);
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right);
      wait1Msec(40);
      //MotorMove_Left(speed_left - offset);
      //MotorMove_Right(speed_right);
      //wait1Msec(40);
      //MotorMove_Left(speed_left);
      //MotorMove_Right(speed_right);
      //wait1Msec(40);
    }
  }

  // When robot is not far from or close to the left walls
  else {
    // When robot is leaving left walls
    if (sonar_value - sonar_value_new >= 5){
      MotorMove_Left(speed_left - offset);
      MotorMove_Right(speed_right);
      wait1Msec(60);
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right);
      wait1Msec(40);
    }
    // When robot is approaching left walls
    else if (sonar_value - sonar_value_new <= -5) {
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right - offset);
      wait1Msec(60);
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right);
      wait1Msec(40);
    }
    // Distance did not change, keep moving forward
    else {
      MotorMove_Left(speed_left);
      MotorMove_Right(speed_right);
      wait1Msec(200);
    }
  }

}

// Not use
void ServoMove(int servoPosition){

  writeDebugStreamLine("Servo Position = %d",servoPosition);
  motor[Servo] = servoPosition;
  wait1Msec(20);
}

// Control left motor
void MotorMove_Left(int motorSpeed){
  writeDebugStream("Motor left Speed = %d", motorSpeed);
  motor[Left_Motor] = -motorSpeed;
  //wait1Msec(200);

}

// Control right motor
void MotorMove_Right(int motorSpeed){
  writeDebugStream("Motor Speed = %d",motorSpeed);
  motor[Right_Motor] = motorSpeed;
  // wait1Msec(200);
}
